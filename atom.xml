<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>Wayne</title>
  
  <subtitle>麤缯大布裹生涯，腹有诗书气自华</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-15T09:58:39.551Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Wayne</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mac环境配置</title>
    <link href="http://yoursite.com/2019/12/15/mac%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/12/15/mac%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2019-12-15T09:58:39.551Z</published>
    <updated>2019-12-15T09:58:39.551Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mac环境配置"><a href="#mac环境配置" class="headerlink" title="mac环境配置"></a>mac环境配置</h1><p>借由这篇文章改变自己的一个环习惯。可能是因为从小就处在这个信息大爆炸的时代，每次遇到问题的时候，总觉得这个问题可以从网上找到答案，更确切的说，总是想着直接百度搜出答案，显然这种行为是不可取的，但是因为这样确实能解决一部分问题，就养成了这个毛病。</p><p>这次是装一个补全插件的时候，遇到了<strong>pyls not found in $PATH</strong>的问题，我又连报错都没细看，直接往搜索框一丢，结果。。。。。绕了大半月都没解决。<br>再之后心想这问题不能一直存在啊，一细看，妈耶是path环境变量的问题，就麻溜给他解决了。</p><a id="more"></a><p>顺便记一下mac下的环境变量相关知识。</p><h2 id="mac系统环境变量加载顺序"><a href="#mac系统环境变量加载顺序" class="headerlink" title="mac系统环境变量加载顺序"></a>mac系统环境变量加载顺序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a. /etc/profile</span><br><span class="line">b. /etc/paths</span><br><span class="line">c. ~/.bash_profile</span><br><span class="line">d. ~/.bash_login</span><br><span class="line">e. ~/.profile</span><br><span class="line">f. ~/.bashrc</span><br></pre></td></tr></table></figure><p>其中a和b是系统级别的，系统启动就会加载，其余是用户级别的。c,d,e按照从前往后的顺序读取，如果c文件存在，则后面的几个文件就会被忽略不读了，以此类推。~/.bashrc没有上述规则，它是bash shell打开的时候载入的。这里建议在c中添加环境变量，以下也是以在c中添加环境变量来演示的:</p><h2 id="编辑环境变量"><a href="#编辑环境变量" class="headerlink" title="编辑环境变量"></a>编辑环境变量</h2><p>mac系统中环境变量编辑语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 中间使用冒号分隔</span><br><span class="line">export PATH=$PATH:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:------:&lt;PATH N&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile  //编辑环境变量</span><br><span class="line">source ～/.bash_profile  //更新缓存变量的缓存</span><br><span class="line">source ~/.zshrc          //如果使用的shell是zsh的话还需要更新zsh</span><br></pre></td></tr></table></figure><p>示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export PYLS=/Users/wayne/Library/Python/2.7/lib/python/site-packages/pyls</span><br><span class="line">export PYLS_HOME=/Users/wayne/Library/Python/2.7/bin</span><br><span class="line">export PATH=$PYLS:$PYLS_HOME:$PATH</span><br></pre></td></tr></table></figure><p>完。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mac环境配置&quot;&gt;&lt;a href=&quot;#mac环境配置&quot; class=&quot;headerlink&quot; title=&quot;mac环境配置&quot;&gt;&lt;/a&gt;mac环境配置&lt;/h1&gt;&lt;p&gt;借由这篇文章改变自己的一个环习惯。可能是因为从小就处在这个信息大爆炸的时代，每次遇到问题的时候，总觉得这个问题可以从网上找到答案，更确切的说，总是想着直接百度搜出答案，显然这种行为是不可取的，但是因为这样确实能解决一部分问题，就养成了这个毛病。&lt;/p&gt;&lt;p&gt;这次是装一个补全插件的时候，遇到了&lt;strong&gt;pyls not found in $PATH&lt;/strong&gt;的问题，我又连报错都没细看，直接往搜索框一丢，结果。。。。。绕了大半月都没解决。&lt;br&gt;再之后心想这问题不能一直存在啊，一细看，妈耶是path环境变量的问题，就麻溜给他解决了。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>半年记</title>
    <link href="http://yoursite.com/2019/11/17/%E5%8D%8A%E5%B9%B4%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/11/17/%E5%8D%8A%E5%B9%B4%E8%AE%B0/</id>
    <published>2019-11-17T10:46:44.000Z</published>
    <updated>2019-12-15T12:16:52.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记2019-4-2019-11"><a href="#记2019-4-2019-11" class="headerlink" title="记2019.4 - 2019.11"></a>记2019.4 - 2019.11</h1><p>  今天是11.17，距离上一篇博客已经有5个月了，离我开始准备找工作也已经有8个月了。那趁着今天将迁移hexo之后，好好回顾下这段时间的生活吧。</p><p>  先说说变化吧，这半年，变化真的很大很大。从windows到linux到windows再到现在的mac。算是把所有系统都用了一遍。从毫无工程经验，只会写一些100来行的简单算法题，到如今个人开发过几个小项目，参与过分布式架构企业级应用开发，了解团队协同开发的基本流程。从不了解春招秋招，简历投了2.30份都无人问津，到现在能拿到offer。这半年，实属不易。</p><a id="more"></a><p>  再谈谈过程吧，嗯，不难想象这段时间很不容易，有想过放弃，在春招投了十多家公司的时候；有过自我怀疑，在努力了四五个月，但还是连向自己心仪的公司投一份简历的勇气都没有的时候；但所幸的是，我坚持下来了。其实这段时间很累，但是很开心。因为我看到了那个十年前，最初接触到电脑知识，了解到一种叫pascal语言的时候，他眼里的光。因为我现在可以很自豪的对他说一句，你是牛的。虽然你并没有一直就在很认真的学习计算机，你也没有一个领路人去指导你在人生的关键路口时该怎么走，但你自己的路，你走对了。你依然在学习着你从小就喜欢的东西，你很荣幸的为自己的热爱在努力。</p><p>  加油，这条路我不知道你会走多久，你能走多远，但我喜欢你会一直热爱它，你会一直知道你该怎么走，与你共勉。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;记2019-4-2019-11&quot;&gt;&lt;a href=&quot;#记2019-4-2019-11&quot; class=&quot;headerlink&quot; title=&quot;记2019.4 - 2019.11&quot;&gt;&lt;/a&gt;记2019.4 - 2019.11&lt;/h1&gt;&lt;p&gt;  今天是11.17，距离上一篇博客已经有5个月了，离我开始准备找工作也已经有8个月了。那趁着今天将迁移hexo之后，好好回顾下这段时间的生活吧。&lt;/p&gt;&lt;p&gt;  先说说变化吧，这半年，变化真的很大很大。从windows到linux到windows再到现在的mac。算是把所有系统都用了一遍。从毫无工程经验，只会写一些100来行的简单算法题，到如今个人开发过几个小项目，参与过分布式架构企业级应用开发，了解团队协同开发的基本流程。从不了解春招秋招，简历投了2.30份都无人问津，到现在能拿到offer。这半年，实属不易。&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂记" scheme="http://yoursite.com/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂技" scheme="http://yoursite.com/tags/%E6%9D%82%E6%8A%80/"/>
    
  </entry>
  
  <entry>
    <title>c/c++内存对齐</title>
    <link href="http://yoursite.com/2019/06/05/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
    <id>http://yoursite.com/2019/06/05/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</id>
    <published>2019-06-05T01:37:28.000Z</published>
    <updated>2019-12-15T09:25:42.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存对齐的原因"><a href="#内存对齐的原因" class="headerlink" title="内存对齐的原因"></a>内存对齐的原因</h1><p><u>内存对齐，是为了让内存存取更有效率而采用的一种编译阶段优化内存存取的手段。</u></p><p>比如对于int x;（这里假设sizeof(int)==4），<strong>因为cpu对内存的读取操作是对齐的</strong>，如果x的地址不是4的倍数，那么读取这个x，需要读取两次共8个字节，然后还要将其拼接成一个int，这比存取对齐过的x要麻烦很多。</p><a id="more"></a><h1 id="内存对齐的原则"><a href="#内存对齐的原则" class="headerlink" title="内存对齐的原则"></a>内存对齐的原则</h1><ol><li><p>数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始(比如int在３２位机为４字节, 则要从４的整数倍地址开始存储),基本类型不包括struct/class/uinon。</p></li><li><p>结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部”最宽基本类型成员”的整数倍地址开始存储.(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.)。</p></li><li><p>收尾工作:结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的”最宽基本类型成员”的整数倍.不足的要补齐.(基本类型不包括struct/class/uinon)。</p></li><li><p>sizeof(union)，以结构里面size最大元素为union的size,因为在某一时刻，union只有一个成员真正存储于该地址。</p></li></ol><h1 id="内存对齐用例"><a href="#内存对齐用例" class="headerlink" title="内存对齐用例"></a>内存对齐用例</h1><p><strong>实例解释：下面以class为代表</strong></p><p>No.1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(Data) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>No.2</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">double</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(Data) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>显然程序No.1 输出的结果为 8    No.2 输出的结果为 16 .</p><p>No.1最大的数据成员是4bytes，1+4=5，补齐为4的倍数，也就是8。而No.2为8bytes，1+8=9，补齐为8的倍数，也就是16。</p><p>No.3</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(Data) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>No.4</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">char</span> d;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(Data) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>No.3运行结果为 12  No.4运行结果为 8</p><p>class中的数据成员放入内存的时候，内存拿出一个内存块来，数据成员们排队一个一个往里放，遇到太大的，不是把自己劈成两半，能放多少放多少，而是等下一个内存块过来。这样的话，就可以理解为什么No.3,No.4两端的代码输出结果不一样了，因为左边是1+（3）+4+1+（3）=12，而右边是1+1+（2）+4=8。括号中为补齐的bytes。</p><p>No.5</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">array</span>[<span class="number">33</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    BigData bd;</span><br><span class="line">    <span class="keyword">int</span> integer;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(BigData) &lt;&lt; <span class="string">"   "</span> &lt;&lt; <span class="keyword">sizeof</span>(Data) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>No.6</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">array</span>[<span class="number">33</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    BigData bd;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(BigData) &lt;&lt; <span class="string">"   "</span> &lt;&lt; <span class="keyword">sizeof</span>(Data) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>No.5和No.6运行结果均为： 48</p><p>在默认条件下，内存对齐是以class中最大的那个基本类型为基准的，如果class中有自定义类型，则递归的取其中最大的基本类型来参与比较。在No.5和No.6中内存块一个接一个的过来接走数据成员，一直到第5块的时候，BigData里只剩1个char了，将它放入内存块中，内存块还剩7个bytes，接下来是个int（4bytes），能够放下，所以也进入第5个内存块，这时候内存块还剩3bytes，而接下来是个double（8bytes），放不下，所以要等下一个内存快到来。因此，No.5的Data的size=33+4+（3）+8=48，同理No.6应该是33+（7）+8=48。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;内存对齐的原因&quot;&gt;&lt;a href=&quot;#内存对齐的原因&quot; class=&quot;headerlink&quot; title=&quot;内存对齐的原因&quot;&gt;&lt;/a&gt;内存对齐的原因&lt;/h1&gt;&lt;p&gt;&lt;u&gt;内存对齐，是为了让内存存取更有效率而采用的一种编译阶段优化内存存取的手段。&lt;/u&gt;&lt;/p&gt;&lt;p&gt;比如对于int x;（这里假设sizeof(int)==4），&lt;strong&gt;因为cpu对内存的读取操作是对齐的&lt;/strong&gt;，如果x的地址不是4的倍数，那么读取这个x，需要读取两次共8个字节，然后还要将其拼接成一个int，这比存取对齐过的x要麻烦很多。&lt;/p&gt;
    
    </summary>
    
    
      <category term="cpp" scheme="http://yoursite.com/categories/cpp/"/>
    
    
      <category term="cpp" scheme="http://yoursite.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>多线程执行顺序打印abc</title>
    <link href="http://yoursite.com/2019/05/31/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0abc/"/>
    <id>http://yoursite.com/2019/05/31/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0abc/</id>
    <published>2019-05-31T08:12:56.000Z</published>
    <updated>2019-11-17T04:23:05.319Z</updated>
    
    <content type="html"><![CDATA[<p>面试的时候遇到的一道题，怪自己贪快了，但是学多线程的时候只是把书上的例子敲了一遍，没有再做别的实践。刚好现在就着这道题把多线程的知识巩固一遍。</p><p>题目：三个线程，要求线程1打印A,线程2打印B,线程3打印C,且要求ABC顺序打印10次</p><p>思考：</p><h1 id="多线程基础API"><a href="#多线程基础API" class="headerlink" title="多线程基础API"></a>多线程基础API</h1><p>首先，最基础的需要用到多线程</p><p>多线程相关API在<a href="https://wwayne1.github.io/2019/05/07/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" target="_blank" rel="noopener">基于线程的并发编程</a>一文中有过较为详细的介绍，这里不做赘述。</p><a id="more"></a><h1 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h1><p>进一步说，如果直接打印，会因为多线程抢占资源而导致顺序不定，且每次输出结果不唯一的情况。因此需要用一个共享变量cnt去计数自己下一步需要打印什么，而为了保证对共享变量的更改正确，又需要用到互斥锁保证线程同步，资源不被抢占。</p><p>　　互斥锁用来保证一段时间内只有一个线程在执行一段代码。必要性显而易见：假设各个线程向同一个文件顺序写入数据，最后得到的结果一定是灾难性的。</p><p>互斥锁是通过锁的机制来实现线程间的同步问题。互斥锁的基本流程为：</p><ul><li>初始化一个互斥锁：pthread_mutex_init()<!--动态分配的互斥量！--></li><li>加锁：pthread_mutex_lock()函数或者pthread_mutex_trylock()函数</li><li>对共享资源的操作</li><li>解锁：pthread_mutex_unlock()函数</li><li>注销互斥锁：pthread_mutex_destory()<!--动态分配的互斥量！！！--></li></ul><p>其中，在加锁过程中，pthread_mutex_lock()函数和pthread_mutex_trylock()函数的过程略有不同：</p><ul><li>当使用pthread_mutex_lock()函数进行加锁时，若此时已经被锁，则尝试加锁的线程会被阻塞，直到互斥锁被其他线程释放，当pthread_mutex_lock()函数有返回值时，说明加锁成功；</li><li>而使用pthread_mutex_trylock()函数进行加锁时，若此时已经被锁，则会返回EBUSY的错误码。</li></ul><p>同时，解锁的过程中，也需要满足两个条件：</p><ul><li>解锁前，互斥锁必须处于锁定状态；</li><li>必须由加锁的线程进行解锁。</li></ul><p><u>需要注意的是，动态分配的互斥锁在malloc后必须使用pthread_mutex_init()初始化，free之前也必须使用pthread_mutex_destory()进行清除。静态分配的则只需要初始化为PTHREAD_MUTEX_INITIALIZER就好了</u></p><h1 id="线程等待和激活"><a href="#线程等待和激活" class="headerlink" title="线程等待和激活"></a>线程等待和激活</h1><p>那么当一个线程不需要打印(没有满足打印条件)的时候，则需要用到线程等待和激活的知识</p><p>首先介绍几个api：</p><p>pthread_cond_t表示多线程的条件变量，用于控制线程等待和就绪的条件。</p><h2 id="条件变量的初始化："><a href="#条件变量的初始化：" class="headerlink" title="条件变量的初始化："></a>条件变量的初始化：</h2><p>条件变量和<a href="http://baike.baidu.com/view/1461738.htm" target="_blank" rel="noopener">互斥锁</a>一样，都有静态动态两种创建方式，</p><p>静态方式使用PTHREAD_COND_INITIALIZER<a href="http://baike.baidu.com/view/346799.htm" target="_blank" rel="noopener">常量</a>初始化。</p><p>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</p><p>动态方式初始化：</p><ol><li>首先要new或者malloc一个pthread_cond_t类型变量，</li></ol><p>​       用完后记得delete或者free掉。</p><ol start="2"><li>动态方式调用<a href="http://baike.baidu.com/view/3750966.htm" target="_blank" rel="noopener">pthread_cond_init</a>()函数，API定义如下：</li></ol><p>​        int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr);</p><h2 id="条件变量的销毁"><a href="#条件变量的销毁" class="headerlink" title="条件变量的销毁"></a>条件变量的销毁</h2><p>注销一个条件变量需要调用pthread_cond_destroy()，只有在没有线程在该条件变量上等待的时候才能注销这个条件变量，否则返回EBUSY。</p><p>因为Linux实现的条件变量没有分配什么资源，所以注销动作只包括检查是否有等待线程。API定义如下：</p><p>int pthread_cond_destroy(pthread_cond_t *cond)</p><p>new开辟的pthread_cond_t记得在调用pthread_cond_destroy()后调用delete或者free销毁掉。</p><h2 id="等待和触发"><a href="#等待和触发" class="headerlink" title="等待和触发"></a>等待和触发</h2><ol><li>条件等待</li></ol><p>int pthread_cond_wait(pthread_cond_t * cond, pthread_mutex_t * mutex); </p><ol start="2"><li>时间等待</li></ol><p>int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);</p><p> 其中计时等待方式如果在给定时刻前条件没有满足，则返回ETIMEOUT，结束等待，</p><p>其中abstime以与time()<a href="http://baike.baidu.com/view/47173.htm" target="_blank" rel="noopener">系统调用</a>相同意义的绝对时间形式出现，0表示<a href="http://baike.baidu.com/view/21246.htm" target="_blank" rel="noopener">格林尼治时间</a>1970年1月1日0时0分0秒。 </p><p>无论哪种等待方式，都必须和一个<a href="http://baike.baidu.com/view/1461738.htm" target="_blank" rel="noopener">互斥锁</a>配合，以防止多个线程同时请求pthread_cond_wait()（或pthread_cond_timedwait()，下同）的<a href="http://baike.baidu.com/view/1346461.htm" target="_blank" rel="noopener">竞争条件</a>（Race Condition）。mutex互斥锁必须是普通锁（PTHREAD_MUTEX_TIMED_NP）或者适应锁（PTHREAD_MUTEX_ADAPTIVE_NP），且在调用pthread_cond_wait()前必须由本<a href="http://baike.baidu.com/view/1053.htm" target="_blank" rel="noopener">线程</a>加锁（pthread_mutex_lock()），而在更新条件<a href="http://baike.baidu.com/view/4083731.htm" target="_blank" rel="noopener">等待队列</a>以前，mutex保持锁定状态，并在线程挂起进入等待前解锁。在条件满足从而离开pthread_cond_wait()之前，mutex将被重新加锁，以与进入pthread_cond_wait()前的加锁动作对应。</p><p>使用pthread_cond_wait方式如下：</p><blockquote><p>​    pthread _mutex_lock(&amp;mutex)</p><p>​    while或if(线程执行的条件是否成立)</p><p>​          pthread_cond_wait(&amp;cond, &amp;mutex);</p><p>​    线程执行</p><p>​    pthread_mutex_unlock(&amp;mutex);</p></blockquote><ol start="3"><li>激发条件有两种形式，pthread_cond_signal()激活一个等待该条件的线程，存在多个等待线程时按入队顺序激活其中一个；而pthread_cond_broadcast()则激活所有等待线程。</li></ol><p> 上面就是多线程条件变量的基础知识，下面着重阐述下为什么调用pthread_cond_wait之前要加锁，以及pthread_cond_wait内部调用了什么。</p><p>  首先解释为什么在等待前加锁，因为线程隶属于进程，线程共享进程的资源，如果不进行加锁，就会造成多个线程同时（相对意义的同时，可能一个线程在函数A中更改此共享资源，此时函数A没结束，另一个线程也访问了这个共享资源）访问这块共享的资源，如果对临界区的内容进行更改，那么两个线程就会造成数据的不准确。所以在更改临界资源的时候要枷锁。而调用pthread_cond_wait之前要加锁也是为了避免多个线程竞争一个条件，造成共享的资源被多个线程更改。所以需要互斥的访问共有资源。那么在pthread_cond_wait之前需要加锁，避免别的线程更改共有资源。</p><p>  接下来思考pthread_cond_wait内部做了哪些操作。</p><p>在pthread_cond_wait调用之前，线程调用pthread_mutex_lock,设置锁，如果条件不满足，那么该线程处于阻塞等待的状态。别的线程发现条件满足后会调用pthread_cond_signal或pthread_cond_broadcast通知他。那么问题出来了，如果该线程不解锁，别的线程是没办法更改共享资源的，也就没办法设置条件变量使其满足该线程的等待条件，出现死锁。所以，pthread_cond_wait会在内部进行解锁操作。别的线程可以访问共享资源，更改条件触发该线程，是该线程从阻塞状态变为就绪。慢一点，还有一个重要的步骤，pthread_cond_wait会将该线程放到线程等待队列里，那么是在放到等待队列之前解锁还是放到等待队列之后才解锁呢？</p><blockquote><p>对于这点apue给出的解释：</p><p>The mutex passed to pthread_cond_wait protects the condition.The caller passes it locked to the function, which then atomically places the calling thread on the list of threads waiting for the condition and unlocks the mutex. This closes the window between the time that the condition is checked and the time that the thread goes to sleep waiting for the condition to change, so that the thread doesn’t miss a change in the condition. When pthread_cond_wait returns, the mutex is again locked.</p></blockquote><p> 这段话的意思是mutex传递给pthread_cond_wait 用于保护条件，调用者将mutex传递给pthread_cond_wait，pthread_cond_wait 会自动将调用该函数的线程放到线程等待队列上，等待条件并且解锁。这种做法关闭了一段间隙，这段间隙就是在我们检测条件的时刻和将线程放到等待队列休眠的时刻之间，这么做该线程不会错过条件的改变。而当pthread_cond_wait 返回时，mutex又被上锁了。</p><p><strong>所以，pthread_cond_wait内部的操作顺序是将线程放到等待队列，然后解锁，等条件满足时进行加锁，然后返回。</strong></p><p><strong>整理下pthread_cond_wait内部操作</strong></p><ol><li><p><strong>线程放在等待队列上，解锁</strong></p></li><li><p><strong>等待 pthread_cond_signal或者pthread_cond_broadcast信号之后去竞争锁</strong></p></li><li><p><strong>若竞争到互斥索则加锁。</strong></p></li></ol><blockquote><p>使用流程</p><p>等待线程：</p><p>pthread_mutex_lock(&amp;mutex);</p><p>if(条件不满足)</p><p>　　pthread_cond_wait(&amp;cond, &amp;mutex);</p><p>//处理共享资源</p><p>pthread_mutex_unlock(&amp;mutex);</p></blockquote><blockquote><p>激活线程：</p><p>pthread_mutex_lock(&amp;mutex);</p><p>pthread_cond_signal(&amp;cond);</p><p>pthread_mutex_unlock(&amp;mutex);</p></blockquote><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>将逻辑串联起来，就把这道题解出来了，最后上代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> item 3</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line">&#125;test = &#123;</span><br><span class="line">PTHREAD_MUTEX_INITIALIZER,</span><br><span class="line">PTHREAD_COND_INITIALIZER,</span><br><span class="line"><span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread</span><span class="params">(<span class="keyword">void</span> *varpg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> t[item];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"开始打印\n"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; item; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> *a = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">*a = i;</span><br><span class="line">pthread_create(&amp;t[i], <span class="literal">NULL</span>, &amp;thread, a);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; item; i++)</span><br><span class="line">pthread_join(t[i],<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread</span><span class="params">(<span class="keyword">void</span> *varpg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> myid = *(<span class="keyword">int</span>*)varpg;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;test.mutex);</span><br><span class="line"><span class="keyword">while</span> (test.cnt != myid)</span><br><span class="line">pthread_cond_wait(&amp;test.cond,&amp;test.mutex);</span><br><span class="line"><span class="keyword">if</span> (myid != <span class="number">2</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,<span class="string">'A'</span>+myid);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c\n"</span>,<span class="string">'A'</span>+myid);</span><br><span class="line">test.cnt = (test.cnt + <span class="number">1</span>)%item;</span><br><span class="line">pthread_mutex_unlock(&amp;test.mutex);</span><br><span class="line">pthread_cond_broadcast(&amp;test.cond);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试的时候遇到的一道题，怪自己贪快了，但是学多线程的时候只是把书上的例子敲了一遍，没有再做别的实践。刚好现在就着这道题把多线程的知识巩固一遍。&lt;/p&gt;&lt;p&gt;题目：三个线程，要求线程1打印A,线程2打印B,线程3打印C,且要求ABC顺序打印10次&lt;/p&gt;&lt;p&gt;思考：&lt;/p&gt;&lt;h1 id=&quot;多线程基础API&quot;&gt;&lt;a href=&quot;#多线程基础API&quot; class=&quot;headerlink&quot; title=&quot;多线程基础API&quot;&gt;&lt;/a&gt;多线程基础API&lt;/h1&gt;&lt;p&gt;首先，最基础的需要用到多线程&lt;/p&gt;&lt;p&gt;多线程相关API在&lt;a href=&quot;https://wwayne1.github.io/2019/05/07/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;基于线程的并发编程&lt;/a&gt;一文中有过较为详细的介绍，这里不做赘述。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络编程" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>基于线程的并发编程</title>
    <link href="http://yoursite.com/2019/05/07/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/05/07/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2019-05-07T11:56:56.000Z</published>
    <updated>2019-11-17T04:21:51.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于线程的并发编程"><a href="#基于线程的并发编程" class="headerlink" title="基于线程的并发编程"></a>基于线程的并发编程</h2><p>线程（thread）就是运行在进程上下文中的逻辑流。线程由内核自动调度。每个线程都有它自己的线程上下文（thread context），包括一个唯一的整数线程ID（Thread ID，TID）、栈、栈指针、程序计数器、通用目的寄存器和条件码。所有运行在一个进程里的线程共享该进程的整个虚拟地址空间。</p><a id="more"></a><h3 id="Posix线程"><a href="#Posix线程" class="headerlink" title="Posix线程"></a>Posix线程</h3><p>Posix线程（Pthreads）是在C程序中处理线程的一个标准接口。下面的Pthreads程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>); <span class="comment">// 返回时，主线程和对等线程同时运行</span></span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>); <span class="comment">// 等待对等线程终止</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, world!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程（main thread）创建一个对等线程（peer thread），然后等待它的终止。对等线程输出”Hello, world!\n”并终止。当主线程检测到对等线程终止后，他就通过调用exit终止该进程。<br>如第二行里的原型所示，每个线程例程都以一个通用指针作为输入，并返回一个通用指针。如果想传递多个参数给线程例程，那么应该将参数放到一个结构中，并传递一个指向该结构的指针。</p><blockquote><p>写程序时忘记函数所需的头文件可以用man来查看，如pthread_create函数可以用<code>man pthread_create</code>命令查看所需头文件。</p></blockquote><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>线程通过调用<code>pthread_create</code>函数来创建其他线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> *(func)(<span class="keyword">void</span> *);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *tid, <span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="function"><span class="params">                func *f, <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure><p>返回：若成功则返回0，若出错则为非零。<br>pthread_create函数创建一个新的线程，并带着一个输入变量arg，在新线程的上下文中运行线程例程f。能用attr参数来改变新创建线程的默认属性。<br>新线程可以通过调用pthread_self函数来获得它自己的线程ID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure><h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><p>一个线程是以下列方式之一来终止的：</p><ul><li><p>当顶层的线程例程返回时，线程会<code>隐式地</code>终止。</p></li><li><p>通过调用pthread_exit函数，线程会<code>显式地</code>终止。如果主线程调用pthread_exit，它会等待所有其他对等线程终止，然后再终止主线程和整个进程，返回值为thread_return。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *thread_return)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>某个对等线程调用Unix的exit函数，该函数终止进程以及所有与改进程相关的线程。</p></li><li><p>另一个对等线程通过以当前线程ID作为参数调用pthread_cancle函数来终止当前线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="回收已终止线程的资源"><a href="#回收已终止线程的资源" class="headerlink" title="回收已终止线程的资源"></a>回收已终止线程的资源</h3><p>线程通过调用pthread_join函数等待其他线程终止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> tid, <span class="keyword">void</span> **thread_return)</span></span>;</span><br></pre></td></tr></table></figure><p>pthread_join函数会阻塞，直到线程tid终止，将线程例程返回的（void *）指针赋值为thread_return指向的位置，然后<code>回收</code>已终止线程占用的所有存储器资源。<br>和Unix的wait函数不同，pthread_join函数只能等待一个指定的线程终止。没有办法让pthread_join等待任意某个线程终止。</p><h3 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h3><p>在任一个时间点，线程是<code>可结合的（joinable）</code>或者是<code>分离的（detached）</code>。一个可结合的线程能被其他线程收回其资源和杀死。一个分离的线程是不能被其他线程回收或杀死的。<br>线程默认是可结合的，<strong>为了避免存储器泄露，每个可结合线程都应该要么被其他线程显式回收，要么通过pthread_detach函数被分离</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="初始化线程"><a href="#初始化线程" class="headerlink" title="初始化线程"></a>初始化线程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_once</span><span class="params">(<span class="keyword">pthread_once_t</span> *once_control, <span class="keyword">void</span> (*init_routine)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>once_control变量是一个全局或者静态变量，总是被初始化为PTHREAD_ONCE_INIT。第一次用参数once_control调用pthread_once时，它调用init_routine，这是一个没有输入参数，也没有返回的函数。（预线程化的并发服务器为示例）</p><blockquote><p>使用初值为<em>PTHREAD_ONCE_INIT</em>的<em>once_control</em>变量保证<em>init_routine()</em>函数在本进程执行序列中仅执行一次。</p><p>在多线程环境中，有些事仅需要执行一次。通常当初始化应用程序时，可以比较容易地将其放在main函数中。但当你写一个库时，就不能在main里面初始化了，你可以用静态初始化，但使用一次初始化（pthread_once）会比较容易些。</p></blockquote><h3 id="一个基于线程的并发服务器"><a href="#一个基于线程的并发服务器" class="headerlink" title="一个基于线程的并发服务器"></a>一个基于线程的并发服务器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"csapp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> connfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> listenfd, *connfdp, port;</span><br><span class="line"><span class="keyword">socklen_t</span> clientlen = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"><span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">listenfd = Open_listenfd(port);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//为了避免对等线程的赋值语句和主线程的accept语句间引入的竞争,动态分配内存块</span></span><br><span class="line">connfdp = Malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">*connfdp = Accept(listenfd, (struct sockaddr*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">Pthread_create(&amp;tid,<span class="literal">NULL</span>,thread,connfdp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> connfd = *((<span class="keyword">int</span> *)vargp);</span><br><span class="line">Pthread_detach(pthread_self());</span><br><span class="line">Free(vargp);</span><br><span class="line">echo(connfd);</span><br><span class="line">Close(connfd);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> connfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> n;</span><br><span class="line"><span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line"><span class="keyword">rio_t</span> rio;</span><br><span class="line"> </span><br><span class="line">Rio_readinitb(&amp;rio, connfd);</span><br><span class="line"><span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"server received %d bytes\n"</span>, (<span class="keyword">int</span>)n);</span><br><span class="line">Rio_writen(connfd, buf, n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对等线程的赋值语句和主线程的Accept语句间引入的竞争：主线程Accept之后，创建新线程执行thread线程例程，同时主线程继续Accept，如果主线程的Accept在新线程的赋值语句之前执行，那么之前的连接就没有被处理，而是处理的下一次连接。因此必须为每个Accept返回的已连接描述符分配不同的动态存储器块。</p></blockquote><p>`</p><h2 id="多线程程序中的共享变量"><a href="#多线程程序中的共享变量" class="headerlink" title="多线程程序中的共享变量"></a>多线程程序中的共享变量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"csapp.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>;</span><br><span class="line"><span class="keyword">char</span> **ptr;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">char</span> *msgs[N] = &#123;</span><br><span class="line">        <span class="string">"Hello from foo"</span>,</span><br><span class="line">        <span class="string">"Hello from bar"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ptr = msgs;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, (<span class="keyword">void</span> *)i);</span><br><span class="line">    Pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myid = (<span class="keyword">int</span>)vargp;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%d]: %s (cnt=%d)\n"</span>, myid, ptr[myid], ++cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>`</p><h3 id="线程存储器模型"><a href="#线程存储器模型" class="headerlink" title="线程存储器模型"></a>线程存储器模型</h3><p>一组并发线程运行在一个进程的上下文中。每个线程都有它自己独立的线程上下文，包括<code>线程ID</code>、<code>栈</code>、<code>栈指针</code>、<code>程序计数器</code>、<code>条件码</code>和<code>通用目的寄存器值</code>。每个线程和其他线程一起共享进程上下文的剩余部分。这包括<code>整个用户虚拟地址空间</code>，它是由只读文本（代码）、读/写数据、堆以及所有的共享库代码和数据区域组成的。<br><strong>将变量映射到存储器</strong></p><ul><li><strong>全局变量</strong> 在运行时，虚拟存储器的读/写区域只包含每个全局变量的一个实例，任何线程都可以引用。</li><li><strong>本地自动变量</strong> 在运行时，每个线程的栈都包含它自己的所有本地自动变量的实例。</li><li><strong>本地静态变量</strong> 和全局变量一样，虚拟内存的读/写区域只包含在程序中声明的每个本地静态变量的一个实例。</li></ul><h2 id="用信号量同步线程"><a href="#用信号量同步线程" class="headerlink" title="用信号量同步线程"></a>用信号量同步线程</h2><p>一个共享变量引入<code>同步错误（synchronization）</code>的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"csapp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> niters;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage: %s &lt;niters&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    niters = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    Pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread, &amp;niters);</span><br><span class="line">    Pthread_create(&amp;tid2, <span class="literal">NULL</span>, thread, &amp;niters);</span><br><span class="line">    Pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt != (<span class="number">2</span> * niters))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"BOOM! cnt=%d\n"</span>, cnt);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"OK cnt=%d\n"</span>, cnt);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, niters =*((<span class="keyword">int</span> *)vargp);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; niters; i++)</span><br><span class="line">        cnt++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>`<br>执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  pthread ./badcnt 10000000</span><br><span class="line">BOOM! cnt=18624047</span><br><span class="line">➜  pthread ./badcnt 10000000</span><br><span class="line">BOOM! cnt=12824971</span><br></pre></td></tr></table></figure><p>会发现当niters足够大时，得到的答案会是错误的，而且每次都不同。因为当badcnt.c中的两个对等线程在一个单处理器上并发运行时，机器指令以某种顺序一个接一个地完成。这些顺序中的一些将会产生正确结果，但其他的则不会。一般而言，没有办法预测操作系统是否将为你的线程选择一个正确的顺序。</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量s是具有非负整数值的全局变量，只能由两种特殊的操作来处理：</p><ul><li><strong>P(s)</strong> 如果s是非零的，P将s减一，并立即返回。如果s为零，那么就挂起这个线程，直到s变为非零。</li><li><strong>V(s)</strong> V操作将s加一。如果有任何线程阻塞在P操作等待s变成非零，那么V操作会重启这些线程中的一个。</li></ul><p>当有多个线程在等待同一个信号量时，不能预测V操作要重启哪个线程。<br>Posix标准定义了许多操作信号量的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="comment">// 将信号量sem初始化为value，每个信号量使用前必须初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="number">0</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="comment">// 程序分别通过调用sem_wait和sem_post函数来执行P和V操作。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *s)</span></span>;</span><br></pre></td></tr></table></figure><p>可以用以下包装函数代替</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"csapp.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">(<span class="keyword">sem_t</span> *s)</span></span>; <span class="comment">// sem_wait的包装函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">V</span><span class="params">(<span class="keyword">sem_t</span> *s)</span></span>; <span class="comment">// sem_post的包装函数</span></span><br></pre></td></tr></table></figure><h3 id="使用信号量来实现互斥"><a href="#使用信号量来实现互斥" class="headerlink" title="使用信号量来实现互斥"></a>使用信号量来实现互斥</h3><p>基本思想是将共享变量与一个信号量s（初始为1）联系起来，然后用P(s)和V(s)操作将相应的临界区包围起来。</p><blockquote><p>临界区：对于线程i，操作共享变量cnt内容的指令构成了一个临界区（critical section）。<br>要确保每个线程在执行它的临界区中的指令时，拥有对共享变量的互斥的访问，这种现象称为互斥（mutual exclusion）。</p></blockquote><p>以这种方式保护共享变量的信号量叫做二元信号量（binary semaphore），因为它的值为0或1。以提供互斥为目的的二元信号量也成为互斥锁（mutex）。在一个互斥锁上执行P操作称为对互斥锁<code>加锁</code>，V操作称为<code>解锁</code>。对一个互斥锁加了锁但是还没有解锁的线程称为<code>占用</code>这个互斥锁。<br>一个被用作一组可用资源的计数器的信号量称为<code>计数信号量</code>。<br>用信号量正确同步前面的计数器程序实例：<br>1.首先声明一个信号量mutex</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">sem_t</span> mutex;</span><br></pre></td></tr></table></figure><p>2.在主例程中，pthread_create之前将mutex初始化为1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>3.通过在线程例程中对共享变量cnt的更新包围P和V操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; niters; i++) &#123;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    cnt++;</span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再编译执行就一定能得到正确结果了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  pthread gcc -o badcnt badcnt.c csapp.c csapp.h -lpthread</span><br><span class="line">➜  pthread ./badcnt 10000000</span><br><span class="line">OK cnt=20000000</span><br><span class="line">➜  pthread ./badcnt 100000000</span><br><span class="line">OK cnt=200000000</span><br></pre></td></tr></table></figure><h3 id="利用信号量来调度共享资源"><a href="#利用信号量来调度共享资源" class="headerlink" title="利用信号量来调度共享资源"></a>利用信号量来调度共享资源</h3><p>一个线程通过信号量操作来通知另一个线程，程序状态中某个条件已经为真了。两个经典而有用的例子是<code>生产者 - 消费者</code>和<code>读者 - 写者</code>问题。<br>1.生产者 - 消费者问题<br>生产者和消费者线程共享一个有n个槽的<code>有限缓冲区</code>。生产者线程反复地生成新的项目，并把它们插入到缓冲区中。消费者线程不断地从缓冲区中取出这些项目，然后消费它们。<br>因为插入和取出项目都涉及更新共享变量，所以我们必须保证对缓冲区的访问是互斥的。但只保证互斥访问是不够的，还需要调度对缓冲区的访问。如果缓冲区是满的，生产者就必须等到有一个槽位变为可用。如果缓冲区是空的，那么消费者必须等到有一个可用项目。<br>下面开发一个简单的包，叫做SBUF，用来构造生产者 - 消费者程序。<br>SBUF操作类型为sbuf_t的有限缓冲区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sbuf.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"csapp.h"</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *buf;    <span class="comment">// 存放项目的动态分配的n项整数数组</span></span><br><span class="line">    <span class="keyword">int</span> n;       <span class="comment">// 槽位的个数</span></span><br><span class="line">    <span class="keyword">int</span> front;   <span class="comment">// 索引值，(front+1)%n记录数组第一项</span></span><br><span class="line">    <span class="keyword">int</span> rear;    <span class="comment">// 索引值，rear%n记录数组最后一项</span></span><br><span class="line">    <span class="keyword">sem_t</span> mutex; <span class="comment">// 提供互斥缓冲区访问的信号量</span></span><br><span class="line">    <span class="keyword">sem_t</span> slots; <span class="comment">// 空槽位数</span></span><br><span class="line">    <span class="keyword">sem_t</span> items; <span class="comment">// 可用项目数</span></span><br><span class="line">&#125; <span class="keyword">sbuf_t</span>;</span><br></pre></td></tr></table></figure><p>SBUF函数的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">"csapp.h"</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sbuf.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_init</span><span class="params">(<span class="keyword">sbuf_t</span> *sp, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 为缓冲区分配堆存储器</span></span><br><span class="line">    sp-&gt;buf = Calloc(n, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    sp-&gt;n = n;</span><br><span class="line">    sp-&gt;front = sp-&gt;rear = <span class="number">0</span>; <span class="comment">// 表示空缓冲区</span></span><br><span class="line">    Sem_init(&amp;sp-&gt;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    Sem_init(&amp;sp-&gt;slots, <span class="number">0</span>, n);</span><br><span class="line">    Sem_init(&amp;sp-&gt;items, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_deinit</span><span class="params">(<span class="keyword">sbuf_t</span> *sp)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 应用程序用完缓冲区时，释放缓冲区存储</span></span><br><span class="line">    Free(sp-&gt;buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_insert</span><span class="params">(<span class="keyword">sbuf_t</span> *sp, <span class="keyword">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P(&amp;sp-&gt;slots); <span class="comment">// wait for available slot</span></span><br><span class="line">    P(&amp;sp-&gt;mutex); <span class="comment">// lock the buffer</span></span><br><span class="line">    sp-&gt;buf[(++sp-&gt;rear) % (sp-&gt;n)] = item; <span class="comment">// insert the item</span></span><br><span class="line">    V(&amp;sp-&gt;mutex); <span class="comment">// unlock the buffer</span></span><br><span class="line">    V(&amp;sp-&gt;items); <span class="comment">// announce available item</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sbuf_remove</span><span class="params">(<span class="keyword">sbuf_t</span> *sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    P(&amp;sp-&gt;items); <span class="comment">// wait for available slot</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);</span><br><span class="line">    item = sp-&gt;buf[(++sp-&gt;front) % (sp-&gt;n)];</span><br><span class="line">    V(&amp;sp-&gt;mutex);</span><br><span class="line">    V(&amp;sp-&gt;slots);</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.读者 - 写者问题<br>一组并发的线程要访问一个共享对象，有些线程只读对象，而其他的线程只修改对象。修改对象的线程叫做<code>写者</code>，只读对象的线程叫做<code>读者</code>。写者必须拥有对对象的独占的访问，而读者可以和无限多个其他的读者共享对象。<br><code>第一类读者 - 写者问题</code> 读者优先，要求不让读者等待，除非已经有写者在占用。<br><code>第二类读者 - 写者问题</code> 写者优先，在写者之后到的读者要等待。<br>第一类读者 - 写者问题的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readcnt; <span class="comment">// 共享变量，统计当前在临界区中的读者数量</span></span><br><span class="line"><span class="keyword">sem_t</span> mutex, w; <span class="comment">// mutex保护对readcnt的访问，w控制对访问共享对象的临界区的访问</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        readcnt++;</span><br><span class="line">        <span class="keyword">if</span> (readcnt == <span class="number">1</span>) <span class="comment">// first in</span></span><br><span class="line">            P(&amp;w);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        <span class="comment">/* Critical section</span></span><br><span class="line"><span class="comment">           Reading happens */</span></span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        readcnt--;</span><br><span class="line">        <span class="keyword">if</span> (readcnt == <span class="number">0</span>) <span class="comment">// last out</span></span><br><span class="line">            V(&amp;w);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(&amp;w);</span><br><span class="line">        <span class="comment">/* Critical section</span></span><br><span class="line"><span class="comment">           Writing happens */</span></span><br><span class="line">        V(&amp;w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="综合：基于预线程化的并发服务器"><a href="#综合：基于预线程化的并发服务器" class="headerlink" title="综合：基于预线程化的并发服务器"></a>综合：基于预线程化的并发服务器</h3><p>一个基于预线程化（prethreading）的服务器通过使用生产者 - 消费者模型来降低为每一个新客户端创建一个新线程的开销。服务器是由一个主线程和一组工作者线程构成的。主线程不断地接收来自客户端的连接请求，并将得到的连接描述符放在一个有限缓冲区中。每一个工作者线程反复地从共享缓冲区中取出描述符，为客户端服务，然后等待下一个描述符。<br>用SBUF包实现一个预线程化的并发echo服务器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"csapp.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NTHREADS 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SBUFSIZE 16</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo_cnt</span><span class="params">(<span class="keyword">int</span> connfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sbuf_t</span> sbuf;   <span class="comment">//已连接描述符的缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, listenfd, connfd, port;</span><br><span class="line"><span class="keyword">socklen_t</span> clientlen = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"><span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">sbuf_init(&amp;sbuf, SBUFSIZE);  <span class="comment">//初始化缓冲区</span></span><br><span class="line">listenfd = Open_listenfd(port);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NTHREADS; i++) &#123;</span><br><span class="line">Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);    <span class="comment">//创建一组工作者线程 why 4?????</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">connfd = Accept(listenfd, (struct sockaddr *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">sbuf_insert(&amp;sbuf, connfd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Pthread_detach(pthread_self());</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;              <span class="comment">//每个工作者线程等待直到它能从缓冲区中取出一个已连接的描述符</span></span><br><span class="line"><span class="keyword">int</span> connfd = sbuf_remove(&amp;sbuf);</span><br><span class="line">echo_cnt(connfd);</span><br><span class="line">Close(connfd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> byte_cnt;  <span class="comment">//记录了所有客户端接收到的累计字节数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">sem_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_echo_cnt</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">byte_cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo_cnt</span><span class="params">(<span class="keyword">int</span> connfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line"><span class="keyword">rio_t</span> rio;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_once_t</span> once = PTHREAD_ONCE_INIT;</span><br><span class="line">Pthread_once(&amp;once, init_echo_cnt);  <span class="comment">// 当第一次有某个线程调用echo_once函数时，使用pthread_once调用初始化函数</span></span><br><span class="line">Rio_readinitb(&amp;rio, connfd);</span><br><span class="line"><span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">P(&amp;mutex);</span><br><span class="line">byte_cnt += n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"thread %d received %d (%d total) bytes on fd %d\n"</span>, (<span class="keyword">int</span>)pthread_self(), n, byte_cnt, connfd);</span><br><span class="line">V(&amp;mutex);</span><br><span class="line">Rio_writen(connfd, buf, n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>`</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基于线程的并发编程&quot;&gt;&lt;a href=&quot;#基于线程的并发编程&quot; class=&quot;headerlink&quot; title=&quot;基于线程的并发编程&quot;&gt;&lt;/a&gt;基于线程的并发编程&lt;/h2&gt;&lt;p&gt;线程（thread）就是运行在进程上下文中的逻辑流。线程由内核自动调度。每个线程都有它自己的线程上下文（thread context），包括一个唯一的整数线程ID（Thread ID，TID）、栈、栈指针、程序计数器、通用目的寄存器和条件码。所有运行在一个进程里的线程共享该进程的整个虚拟地址空间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络编程" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="csapp" scheme="http://yoursite.com/tags/csapp/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>基于io多路复用的并发事件驱动服务器</title>
    <link href="http://yoursite.com/2019/04/29/%E5%9F%BA%E4%BA%8EIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2019/04/29/%E5%9F%BA%E4%BA%8EIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2019-04-29T14:14:24.000Z</published>
    <updated>2019-11-17T04:13:34.771Z</updated>
    
    <content type="html"><![CDATA[<p>例子：echo（响应）服务器，能对用户从标准输入键入的命令作出响应、分析：服务器必须分别响应两种相互独立的I/O事件：1，网络客户端发起连接请求 2，用户在键盘上键入命令行;</p><p>问题：我们先等待哪个事件呢？如果在accept中等待一个连接请求，我们就不能响应输入的命令;如果在read中等待一个输入命令，我们就不能响应任何连接的请求。</p><a id="more"></a><p>解决方法：IO多路复用技术</p><p>思路：利用select函数，要求内核挂起进程，只有在一个或多个IO事件发生后，才将控制返回给应用程序。例如，当{1，2，7}中任意描述符准备好写时返回。</p><p>select是一个复杂的函数，有许多不同的使用场景，现在先只考虑一组描述符准备好读，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="number">2</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="number">3</span> <span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> n,fd_set *fdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span></span>;<span class="comment">//返回值，表示已经准备好的描述符的非零的个数，若出错则为-1</span></span><br><span class="line">FD_ZERO(fd_set *fdset)<span class="comment">//在fdset清空所有的位</span></span><br><span class="line">FD_CLR(<span class="keyword">int</span> fd, fd_set *fdset)<span class="comment">//清空fdset中的fd位</span></span><br><span class="line">FD_SET(<span class="keyword">int</span> fd, fd_set *fdset)<span class="comment">//将fdset中的fd位置位</span></span><br><span class="line">FD_ISSET(<span class="keyword">int</span> fd,fd_set *fdset)<span class="comment">//判断fdset中的fd位</span></span><br></pre></td></tr></table></figure><p>select函数处理类型为fd_set的集合，就是描述符集合。逻辑上，我们将描述符集合看成是一个大小为n的位向量，b(n-1),….b(1),b(0)</p><p>每个b(k)对应与描述符k，当且仅当b(k)=1，才表明描述符k是描述符集合中的一个元素。只允许你对描述符集合做三件事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1，分配它们</span><br><span class="line">2，将一个此种类型的变量赋值给另一个变量</span><br><span class="line">3，使用FD_ZERO,FD_SET,FD_CLR,FD_ISSET宏指令来修改和检查它们</span><br></pre></td></tr></table></figure><p>针对问题，select函数有两个输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1，一个称为读集合的描述符集合fdset</span><br><span class="line">2，该读集合的基数n（实际上就是任何描述符集合的最大基数）</span><br></pre></td></tr></table></figure><p>select函数会一直阻塞，直到至少有一个描述符准备好可以读了。</p><p>那么问题是，什么时候代表一个描述符可以读了呢？当且仅当一个从该描述符读取一个字节的请求不会阻塞时，描述符k就表示可以读了。</p><p>问题是，select修改了参数fdset指向的fd_set，指明读集合中一个称为准备好（ready set）的子集，这个集合是由读集合中准备好可以读了的描述符组成的。函数返回的值指明了准备好集合的基数（个数）;由于这个问题的存在，我们必须在每次调用select时都等新读集合。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment"> *Author*        :wayne</span></span><br><span class="line"><span class="comment"> *Description*   :select的示例       </span></span><br><span class="line"><span class="comment"> *Created Time*  : 2019年04月29日 星期一 22时21分57秒</span></span><br><span class="line"><span class="comment"> * Ended  Time*  : 2019年04月29日 星期一 22时22分03秒</span></span><br><span class="line"><span class="comment">**************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"csapp.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> connfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">command</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd, port;</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    fd_set read_set, ready_set;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    listenfd = Open_listenfd(port);  <span class="comment">//line:conc:select:openlistenfd</span></span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;read_set);              <span class="comment">/* Clear read set */</span> <span class="comment">//line:conc:select:clearreadset</span></span><br><span class="line">    FD_SET(STDIN_FILENO, &amp;read_set); <span class="comment">/* Add stdin to read set */</span> <span class="comment">//line:conc:select:addstdin</span></span><br><span class="line">    FD_SET(listenfd, &amp;read_set);     <span class="comment">/* Add listenfd to read set */</span> <span class="comment">//line:conc:select:addlistenfd</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">ready_set = read_set;    <span class="comment">//更新读集合</span></span><br><span class="line">Select(listenfd+<span class="number">1</span>, &amp;ready_set, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">//line:conc:select:select</span></span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(STDIN_FILENO, &amp;ready_set)) <span class="comment">//line:conc:select:stdinready</span></span><br><span class="line">    command(); <span class="comment">/* Read command line from stdin */</span></span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(listenfd, &amp;ready_set)) &#123; <span class="comment">//line:conc:select:listenfdready</span></span><br><span class="line">    connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">    echo(connfd); <span class="comment">/* Echo client input until EOF */</span></span><br><span class="line">    Close(connfd);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> connfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> n;</span><br><span class="line"><span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line"><span class="keyword">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">Rio_readinitb(&amp;rio, connfd);</span><br><span class="line"><span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"server received %d bytes\n"</span>, (<span class="keyword">int</span>)n);</span><br><span class="line">Rio_writen(connfd,buf,n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">command</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">if</span> (!Fgets(buf, MAXLINE, <span class="built_in">stdin</span>))</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* EOF */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, buf); <span class="comment">/* Process the input command */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end select */</span></span><br></pre></td></tr></table></figure><p>分析代码：while循环第二行中不是调用accept函数来等待一个连接请求，而是调用select函数，这个函数会一直阻塞，直到listenfd或stdin_fileno准备好可以读了。<br>一旦select返回，我们就调用FD_ISSET宏指令来判断哪个描述符准备好可以读了：1，如果是标准输入读了，就调用command函数，该函数在返回主程序前，会读、解析和响应命令 2，如果是监听描述符准备好了，我们就调用accept来得到一个connfd，然后调用echo函数，它将来自client的每一行回送回去，直到这个client关闭这个连接中它的那一端。</p><p>代码问题：一旦它连接到某个客户端，就会连续回送输入行，直到客户端关闭这个连接中它的那一端。就是说，你在server端键入一个命令到标准输入，server端不会得到响应，直到server和client之间断开。</p><p>解决方法：可以采用更细粒度的多路复用，server每次循环（至多）回送一个文本行。</p><hr><p><strong>基于IO多路复用的并发事件驱动服务器</strong></p><p>IO多路复用可以用作并发时间驱动（event-driven）程序的基础。在事件驱动程序中，流是因为某种事件而前进的，一般概念就是将逻辑流模型化为状态机。状态机就是一组状态、输入事件、转移，其中转移就是将状态和输入事件映射到状态。每个状态都是将一个（输入状态、输入事件）映射到一个输出状态。自循环是同一个输入和输出状态之间的转移。</p><p>通常将状态机化为有向图，节点表示状态，有向弧表示转移，弧上的标号表示输入事件。</p><hr><p>对于每一个客户端k，基于IO多路复用的并发服务器会创建一个新的状态机s(k)，并将它和已连接描述符d(k)联系起来。即每个状态机s(k)都有一个状态（“等待描述符d(k)准备好读”），一个输入事件（“描述符dk准备好可以读了”）和一个转移（从描述符dk读一个文本行）;</p><p>一定少不了select函数检测输入是事件的发生，当每个connfd准备好读时，server就为响应的状态机执行转移，就是从描述符读和写一个文本行;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">感悟：</span></span><br><span class="line"><span class="comment">1.当没有进行操作时，程序是阻塞在select函数的。</span></span><br><span class="line"><span class="comment">2.当监听到新的客户端连接时，select返回的ready_set中listenfd位会变为1</span></span><br><span class="line"><span class="comment">3.当监听到已连接的客户端发送文本行时，select返回的ready_set中相应的connfd位为1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"csapp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//维护活动客户端的集合</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">//表示connfd连接描述符的池子</span></span><br><span class="line"><span class="keyword">int</span> maxfd;   <span class="comment">//read_set中最大的描述符</span></span><br><span class="line">fd_set read_set;    <span class="comment">//所有已连接描述符的集合</span></span><br><span class="line">fd_set ready_set;     <span class="comment">//准备好读的描述符(已连接描述符的子集)</span></span><br><span class="line"><span class="keyword">int</span> nready;          <span class="comment">//从select函数中返回的 所有准备好读的 描述符数量</span></span><br><span class="line"><span class="keyword">int</span> maxi;           <span class="comment">//到client数组的最大索引</span></span><br><span class="line"><span class="keyword">int</span> clientfd[FD_SETSIZE];         <span class="comment">//已连接描述符的集合,-1代表可用</span></span><br><span class="line"><span class="keyword">rio_t</span> clientrio[FD_SETSIZE];    <span class="comment">//已连接描述符的读缓冲区集合</span></span><br><span class="line">&#125;pool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_pool</span><span class="params">(<span class="keyword">int</span> listenfd, pool *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_client</span><span class="params">(<span class="keyword">int</span> connfd, pool *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_clients</span><span class="params">(pool *p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> byte_cnt = <span class="number">0</span>;  <span class="comment">//统计server收到的全部字节数量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> listenfd, connfd, port;</span><br><span class="line"><span class="keyword">socklen_t</span> clientlen = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"><span class="keyword">static</span> pool pool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">listenfd = Open_listenfd(port);</span><br><span class="line">init_pool(listenfd, &amp;pool);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">pool.ready_set = pool.read_set;</span><br><span class="line">pool.nready = Select(pool.maxfd+<span class="number">1</span>, &amp;pool.ready_set, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//printf("---------------%d\n",pool.nready);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果listenfd准备好可以读了，就添加新的client到pool中</span></span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(listenfd, &amp;pool.ready_set)) &#123;</span><br><span class="line">connfd = Accept(listenfd,(struct sockaddr*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line"><span class="comment">//printf("---------------%d\n",connfd);</span></span><br><span class="line">add_client(connfd,&amp;pool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_clients(&amp;pool);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_pool</span><span class="params">(<span class="keyword">int</span> listenfd, pool *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">/* 初始化为-1 */</span></span><br><span class="line">p-&gt;maxi = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">p-&gt;clientfd[i] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">p-&gt;maxfd = listenfd;</span><br><span class="line">FD_ZERO(&amp;p-&gt;read_set);</span><br><span class="line">FD_SET(listenfd, &amp;p-&gt;read_set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_client</span><span class="params">(<span class="keyword">int</span> connfd, pool *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">p-&gt;nready--;   <span class="comment">//减掉监听描述符，这里减了之后，连接新的客户端的那次循环就不会进入check_clients的for循环</span></span><br><span class="line"><span class="comment">//printf("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;.%d\n",p-&gt;nready);</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;clientfd[i] &lt; <span class="number">0</span>)&#123;   <span class="comment">//找到一个空槽位</span></span><br><span class="line">p-&gt;clientfd[i] = connfd;</span><br><span class="line">Rio_readinitb(&amp;p-&gt;clientrio[i], connfd);</span><br><span class="line"></span><br><span class="line">FD_SET(connfd, &amp;p-&gt;read_set);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (connfd &gt; p-&gt;maxfd)</span><br><span class="line">p-&gt;maxfd = connfd;</span><br><span class="line"><span class="keyword">if</span> (i &gt; p-&gt;maxi)</span><br><span class="line">p-&gt;maxi = i;</span><br><span class="line"><span class="comment">//printf("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;.%d maxi = %d\n",p-&gt;nready,p-&gt;maxi);</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == FD_SETSIZE)  <span class="comment">//找不到空槽位了</span></span><br><span class="line">app_error(<span class="string">"add_client error: Too many clients"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_clients</span><span class="params">(pool *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, connfd, n;</span><br><span class="line"><span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line"><span class="keyword">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; (i &lt;= p-&gt;maxi) &amp;&amp; (p-&gt;nready &gt; <span class="number">0</span>); i++)</span><br><span class="line">&#123;</span><br><span class="line">connfd = p-&gt;clientfd[i];</span><br><span class="line">rio = p-&gt;clientrio[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果这个描述符准备好了，从这个描述符回送一个文本行</span></span><br><span class="line"><span class="keyword">if</span> ((connfd &gt; <span class="number">0</span>) &amp;&amp; (FD_ISSET(connfd, &amp;p-&gt;ready_set))) &#123;</span><br><span class="line"><span class="comment">//printf("...................%d\n",p-&gt;nready);</span></span><br><span class="line">p-&gt;nready--;</span><br><span class="line"><span class="keyword">if</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>)&#123;</span><br><span class="line">byte_cnt += n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Server received %d (%d total) bytes on fd %d\n"</span>,n, byte_cnt,connfd);</span><br><span class="line">Rio_writen(connfd, buf, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">//检测到EOF，从池子中移走描述符</span></span><br><span class="line">Close(connfd);</span><br><span class="line">FD_CLR(connfd, &amp;p-&gt;read_set);</span><br><span class="line">p-&gt;clientfd[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>select函数检测输入事件，add_client函数创建一个新的逻辑流（状态机）,check_clients函数通过回送输入行来执行状态转移，而且当客户端完成文本发送时，还要删除这个状态机。</p><hr><p>IO多路复用技术的优劣：</p><p>好处：</p><p>1，它比基于进程的设计给了程序员更多的对程序行为的控制，例如我们可以写一个事件驱动的并发服务器，为某些客户端提供它们需要的服务;这对进程并发服务器来说很难。</p><p>2，一个基于IO多路复用的事件驱动服务器是运行在单一进程上下文中的，因此每个逻辑流都能访问该进程的全部地址空间，所以共享数据很容易。</p><p>3，与单进程运行相关的，可以使用GDB来调试并发服务器，就像顺序程序那样</p><p>4，事件驱动程序比基于进程的设计要高效的过，不需要切换进程上下文来调度新的流</p><p>缺点：</p><p>1，编码复杂，随着并发粒度的减小，复杂性还会上升。粒度指的是，每个逻辑流每个时间片执行的指令数量，在这个例子中，粒度就是杜伊个完整的文本行所需要的指令数量，<br>因为只要有一个逻辑流忙于读一个文本行，其他逻辑流就不可能有进展。但是这会容易因此 client发送部分文本然后快开的，恶意攻击。</p><p>2，不能充分利用多核处理器</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;例子：echo（响应）服务器，能对用户从标准输入键入的命令作出响应、分析：服务器必须分别响应两种相互独立的I/O事件：1，网络客户端发起连接请求 2，用户在键盘上键入命令行;&lt;/p&gt;&lt;p&gt;问题：我们先等待哪个事件呢？如果在accept中等待一个连接请求，我们就不能响应输入的命令;如果在read中等待一个输入命令，我们就不能响应任何连接的请求。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络编程" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="csapp" scheme="http://yoursite.com/tags/csapp/"/>
    
  </entry>
  
</feed>
